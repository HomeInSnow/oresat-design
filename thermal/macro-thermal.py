#!/usr/bin/python


##########
#This is Rev 0.1 of an average temperature simulation for the Portland State Aerospace Society's cubesat project, OreSat.
#It makes a number of assumptions about composition, orbit, surface characteristics, and assumes away problems of angle.
#Features to be implemented:
#	-Earthshine contribution to total insolation
#	-Difference in radiation out between Earth-facing side and space-facing side
#	-Orientation of sat with respect to incident rays
#	-Power consumption profile
#	-Options for thermal regulation devices, like phase change regulation?
#
#Written by Aaron Baker
#

from __future__ import division
import ephem				#pyephem is an open-source ephemeris package that we use to generate orbital data over time
import datetime				#datetime lets us do reliable time comparisons with a pre-built library
import matplotlib.pyplot as plt

start_time = datetime.datetime.now()

TLE_line1 = "ISS (ZARYA)"									#load the TLE; want to implement a method from CelesTrak
TLE_line2 = "1 25544U 98067A   15306.33154501  .00009977  00000-0  15416-3 0  9999"
TLE_line3 = "2 25544  51.6441 114.6139 0006754 101.7020 328.7420 15.54757498969534"

sat = ephem.readtle(TLE_line1, TLE_line2, TLE_line3)

data_array = []

current_time = start_time		#set the simulation start time
delta_t = 1				#time step (in seconds)
num_t	= 60*60*24*4			#number of time steps

face_angle_1 = 0			#see discussion in SMAD; use this to calculate the profile projection of the faces?
face_angle_2 = 0			#I can't figure the geometry out though


start_temp = 273			#start temperature in K
specific_heat = 0.9 			#deg J/g-K, of aluminum at 25 degrees
mass = 1300				#mass of the cubesat, g
heat_capacity = specific_heat*mass	#heat capacity of satellite, J/K
current_heat = start_temp*heat_capacity

average_power_generation = 5		#mean power generated by the satellite internally. 5W at a guess.

pv_reflectivity = 0.1					#values from "A Simplified Thermal Model for Flat-Plate PV Arrays," Fuentes 87	
pv_efficiency = 0.3					#presumably we will want swag solar cells since we have such a small area			
pv_absorptivity = (1-pv_reflectivity)*(1-pv_efficiency) #equation from "A simplified Thermal Model for Flat-Plate PV Arrays," Fuentes 87
pv_emissivity = 0.85			
pv_area = 90						#area of solar panels on one face, in cm^2

structure_absorptivity = 0.5				#typical value for aluminum
structure_emissivity = 0.1				#polished aluminum
structure_area = 10					#area of structure on one face, in cm^2

mean_absorptivity = (pv_area*pv_absorptivity + structure_area*structure_emissivity)/(pv_area + structure_area)
							#this is a guess as to how this should work - average absorptivity
							#for the surface weighted by surface area to get a combined absorptivity

mean_emissivity = (pv_area*pv_emissivity + structure_area*structure_emissivity)/(pv_area + structure_area)

solar_constant = 1366				#solar constant, W/m^2
sigma = 5.67051E-8				#boltzmann's constant, W/m^2-K^4

projected_area = .01				#projected area of the plate towards the sun, m^2 (one 10x10cm face)
radiating_area = .06				#radiating area of the plate, m^2		  (six 10x10cm faces)



for i in xrange(num_t):
	sat.compute(current_time)										#update the satellite's position after delta_t

	#update heat total based on radiation in, radiation out, internal power dissipation (and earthshine at some point)
	current_heat -= radiating_area*mean_emissivity*sigma*delta_t*(current_heat/heat_capacity)**4 	#radiation out (needs to be fixed to reflect earth on one side, see SMAD)
	current_heat += sat.eclipsed*solar_constant*delta_t*projected_area*mean_absorptivity 		#sunshine in
	current_heat += average_power_generation*delta_t						#total guess; has a large impact on our eventual steady state solution though so we want
													#to nail this down much better
#	current_heat += earthshine

	current_temp = current_heat/heat_capacity								#based on estimate of mass and composition having the specific heat of aluminum
#	print "%s: %s, %g(J), %g(deg K)"%(sat.eclipsed, current_time.isoformat(), current_heat, current_temp)	#debug info

	data_array.append((current_time, sat.eclipsed, current_heat, current_temp))
	current_time = current_time + datetime.timedelta(0, delta_t)						#update time will break if delta_t > 86k seconds, but it shouldn't be that big anyway

time = [(t - start_time).total_seconds()/3600 for t in zip(*data_array)[0]]					#display time is in hours (seconds/3600)
														#t and start_time are datetime.datetime objects; subtracting them gives a
														#datetime.timedelta object; method total_seconds gives us the total seconds
temp = zip(*data_array)[3]				#unpack temp from our array
plt.plot(time, temp)					#plot time vs. temp 							
plt.xlabel('Time (hours)')
plt.ylabel('Temp (K)')
plt.savefig('initial_plot.png')
plt.show()

